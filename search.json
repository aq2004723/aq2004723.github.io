[{"title":"java full gc 频繁问题排查","url":"/2020/05/06/日志/","content":"\n# java full gc 频繁问题排查\n排查full gc问题首先要知道什么情况下会发生full gc\n\n\n> 作者：Ted Mosby  \n> 链接：https://www.zhihu.com/question/41922036/answer/144566789  \n> 来源：知乎  \n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  \n> 1. Full GC定义是相对明确的，就是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC；  \n>   \n> 2. Minor GC和Major GC是俗称，在Hotspot JVM实现的Serial GC, Parallel GC, CMS, G1 GC中大致可以对应到某个Young GC和Old GC算法组合；  \n>   \n> 3. 最重要是搞明白上述Hotspot JVM实现中几种GC算法组合到底包含了什么。  \n> 3.1 Serial GC算法：Serial Young GC ＋ Serial Old GC （敲黑板！敲黑板！敲黑板！实际上它是全局范围的Full GC）；  \n> 3.2 Parallel GC算法：Parallel Young GC ＋ 非并行的PS MarkSweep GC / 并行的Parallel Old GC（敲黑板！敲黑板！敲黑板！这俩实际上也是全局范围的Full GC），选PS MarkSweep GC 还是 Parallel Old GC 由参数UseParallelOldGC来控制；  \n> 3.3 CMS算法：ParNew（Young）GC + CMS（Old）GC （piggyback on ParNew的结果／老生代存活下来的object只做记录，不做compaction）＋ Full GC for CMS算法（应对核心的CMS GC某些时候的不赶趟，开销很大）；3.4 G1 GC：Young GC + mixed GC（新生代，再加上部分老生代）＋ Full GC for G1 GC算法（应对G1 GC算法某些时候的不赶趟，开销很大）；  \n>   \n> 4. 搞清楚了上面这些组合，我们再来看看各类GC算法的触发条件。简单说，触发条件就是某GC算法对应区域满了，或是预测快满了。比如，  \n> 4.1 各种Young GC的触发原因都是eden区满了；  \n> 4.2 Serial Old GC／PS MarkSweep GC／Parallel Old GC的触发则是在要执行Young GC时候预测其promote的object的总size超过老生代剩余size；  \n> 4.3 CMS GC的initial marking的触发条件是老生代使用比率超过某值；  \n> 4.4 G1 GC的initial marking的触发条件是Heap使用比率超过某值，跟4.3 heuristics 类似；  \n> 4.5 Full GC for CMS算法和Full GC for G1 GC算法的触发原因很明显，就是4.3 和 4.4 的fancy算法不赶趟了，只能全局范围大搞一次GC了（相信我，这很慢！这很慢！这很慢！）；  \n> 5 题主说的 “Full GC会先触发一次Minor GC” － 指的应该是5.1 （说错了，我删了）  \n> 5.2 PS MarkSweep GC／Parallel Old GC（Full GC）之前会跑一次Parallel Young GC；原因就是减轻Full GC 的负担。哇～整个picture 是有点乱，希望我整理的还算清楚：）  \n\n总结起来，full gc的触发根据回收器的不同有以下几种可能\n\n1. 老年代空间不足\n2. Permanet Generation空间满\n3. CMS GC时出现promotion failed和concurrent mode failure\n4. Serial Old GC／PS MarkSweep GC／Parallel Old GC的触发则是在要执行Young GC时候预测其promote的object的总size超过老生代剩余size\n\n\n对应的表现以及解决方式：\n## 老年代空间不足\n连续多次触发full gc，old gen 空间占比高，甚至直接抛出`java.lang.OutOfMemoryError: Java heap space `\n\n解决方案，调整jvm参数，扩大老年代比率，或者直接扩大堆空间\n\n## Permanet Generation空间满\n\n连续多次触发full gc， Permanet Generation空间占比高\n\n解决方案：扩大Perm 大小\n\n## CMS GC时出现promotion failed和concurrent mode failure\n查询gc日志\npromotion failed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。\n\n解决方案：增大survivor space、old gen 空间\n\n## Serial Old GC／PS MarkSweep GC／Parallel Old GC的触发则是在要执行Young GC时候预测其promote的object的总size超过老生代剩余size\n解决方案：增大old gen 空间\n"},{"title":"jvm垃圾回收总结","url":"/2020/05/06/jvm垃圾回收总结/","content":"\n# jvm垃圾回收总结\n\n## 4种垃圾回收算法\n1. 标记-清除\n1. 复制算法\n1. 标记-整理\n1. 分代收集\n\n#### 标记-清除\n分为两个步骤\n标记出所有要回收对象：\n一般使用根节点，所有通过节点不可达的对象将被标记\n回收所有已标记对象\n回收被标记对象的内存\n\n缺点：效率低，产生碎片\n\n#### 复制算法\n将内存分为两个部分，当一个部分满了后，将所有存活对象连续的复制到另一部分，并且清楚老的部分的全部对象内存\n\n优点：解决的了标记-清楚算法产生的碎片问题\n缺点: 只使用了一个一半内存，资源浪费严重，存活对象较多会复制会产生较大开销\n\n>为了解决内存浪费的问题\n将内存区域化为一个Eden区和两个survivor区，每次使用Eden区和一个survivor区\n过程是一个对eden区和一个survivor区进行垃圾回收 将存活对象复制到另一个survivor区\n\n\n#### 标记-整理\n标记-整理方法大致和标记清楚算法一致，标记后不清楚，将对象复制到一端，清楚尾端\n\n#### 分代收集\n现代虚拟机均使用这种方案\n一般将内存分为两个部分 新生代和老年代\n\n新生代有大量新对象产生，又会有大量对象被回收，采用复制算法\n\n老年代对象相对长期存活 使用标记-清除或标记-整理算法\n\n\n## 几种垃圾收集器实现对比\n![几种垃圾收集器实现](http://image.hloli.me/18-03-27/1522123699340.jpg)\n\n垃圾回收器 | 实现算法 | 作用空间 | 实现描述 | 适用场景 | 优点 | 缺点\n---- | --- | ---- | --- | --- | --- | --- |\n Serial | 复制算法 | 新生代 | 暂停所有用户线程，执行gc线程，默认运行在client模式下 | 简单程序、小型客户端程序 | 简单、高效，针对单cpu构架有很好的表现 | stop the world，表现为程序卡顿\n ParNew 收集器|  复制算法 | 新生代 | Serial收集器的多线程版本 | server模式下首选的模式| 能与CMS收集器一起作用，在多核心情况下相比Serial有较高效率 |\n paralled scavenge收集器| 复制算法 | 新生代  |  更关注吞吐量，即运行中占总时间（运行时间+gc时间）的百分比，可以不指定Eden区和suvivor区比例，系统根据运行情况自动调节| 更关注吞吐量的情况，对CPU资源敏感 |\n Serial Old 收集器| 标记-整理 | 老年代 | Serial算法的老年代版本 | client模式下默认的老年带收集器，在Server模式下常作为CMS失效的情况下的后备收集算法 |\n paralled old 收集器| 多线程的 标记-整理算法 | 老年代 | 配合 paralled scavenge收集器 完成对cpu资源敏感的收集 | 与  paralled scavenge收集器 配合使用\n CMS收集器 | 标记清除 | 老年代 | 目标是停顿时间最短，实现见下面的讨论 |  互联网BS构架中常用的服务端收集器 | 并发收集、低停顿 | CPU敏感，默认线程数是（CPU数量 + 3 ) / 4,少于4个cpu的情况下有时会显著降低反应速度， 其次，因为浮动垃圾的存在有时会发生 收集失败，从而触发full gc 导致时间变长。使用标记-清除算法，有碎片问题产生，碎片过多也会触发full gc\n g1 收集器| 标记-整理 加 复制 | 全堆空间 | 详细见下面 | 用于在BS构架中替代CMS\n\n#### CMS 垃圾收集器简述\n分为四个阶段\n* 初始标记   标记根对象\n* 并发标记   标记可达对象\n* 重新标记   标记产生变动的对象\n* 并发清除   编发清除\n\n过程如下图\n![img](http://image.hloli.me/18-03-27/1522139736358.jpg)\n前三个阶段会触发停顿\n\n\n#### G1 垃圾收集器简述\n暂无\n\n\n\n## 垃圾收集器参数总结\n ![img](http://image.hloli.me/18-03-27/1522139358525.jpg)\n\n\n\n## 选用问题\n使用spring进行开发时一般根据cpu核心数来进行选择（如无特殊需求）\n大于等于4核心 使用CMS + ParNew 收集器\n小于4核心    使用  Serial Old  + ParNew 收集器\n\ng1收集器目前还没有使用过，不做评价，但是越来越多的项目使用G1收集器  值得考虑\n"},{"title":"java full gc 频繁问题排查","url":"/2020/05/06/java full gc 频繁问题排查/","content":"\n# java full gc 频繁问题排查\n排查full gc问题首先要知道什么情况下会发生full gc\n\n\n> 作者：Ted Mosby  \n> 链接：https://www.zhihu.com/question/41922036/answer/144566789  \n> 来源：知乎  \n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  \n> 1. Full GC定义是相对明确的，就是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC；  \n>   \n> 2. Minor GC和Major GC是俗称，在Hotspot JVM实现的Serial GC, Parallel GC, CMS, G1 GC中大致可以对应到某个Young GC和Old GC算法组合；  \n>   \n> 3. 最重要是搞明白上述Hotspot JVM实现中几种GC算法组合到底包含了什么。  \n> 3.1 Serial GC算法：Serial Young GC ＋ Serial Old GC （敲黑板！敲黑板！敲黑板！实际上它是全局范围的Full GC）；  \n> 3.2 Parallel GC算法：Parallel Young GC ＋ 非并行的PS MarkSweep GC / 并行的Parallel Old GC（敲黑板！敲黑板！敲黑板！这俩实际上也是全局范围的Full GC），选PS MarkSweep GC 还是 Parallel Old GC 由参数UseParallelOldGC来控制；  \n> 3.3 CMS算法：ParNew（Young）GC + CMS（Old）GC （piggyback on ParNew的结果／老生代存活下来的object只做记录，不做compaction）＋ Full GC for CMS算法（应对核心的CMS GC某些时候的不赶趟，开销很大）；3.4 G1 GC：Young GC + mixed GC（新生代，再加上部分老生代）＋ Full GC for G1 GC算法（应对G1 GC算法某些时候的不赶趟，开销很大）；  \n>   \n> 4. 搞清楚了上面这些组合，我们再来看看各类GC算法的触发条件。简单说，触发条件就是某GC算法对应区域满了，或是预测快满了。比如，  \n> 4.1 各种Young GC的触发原因都是eden区满了；  \n> 4.2 Serial Old GC／PS MarkSweep GC／Parallel Old GC的触发则是在要执行Young GC时候预测其promote的object的总size超过老生代剩余size；  \n> 4.3 CMS GC的initial marking的触发条件是老生代使用比率超过某值；  \n> 4.4 G1 GC的initial marking的触发条件是Heap使用比率超过某值，跟4.3 heuristics 类似；  \n> 4.5 Full GC for CMS算法和Full GC for G1 GC算法的触发原因很明显，就是4.3 和 4.4 的fancy算法不赶趟了，只能全局范围大搞一次GC了（相信我，这很慢！这很慢！这很慢！）；  \n> 5 题主说的 “Full GC会先触发一次Minor GC” － 指的应该是5.1 （说错了，我删了）  \n> 5.2 PS MarkSweep GC／Parallel Old GC（Full GC）之前会跑一次Parallel Young GC；原因就是减轻Full GC 的负担。哇～整个picture 是有点乱，希望我整理的还算清楚：）  \n\n总结起来，full gc的触发根据回收器的不同有以下几种可能\n\n1. 老年代空间不足\n2. Permanet Generation空间满\n3. CMS GC时出现promotion failed和concurrent mode failure\n4. Serial Old GC／PS MarkSweep GC／Parallel Old GC的触发则是在要执行Young GC时候预测其promote的object的总size超过老生代剩余size\n\n\n对应的表现以及解决方式：\n## 老年代空间不足\n连续多次触发full gc，old gen 空间占比高，甚至直接抛出`java.lang.OutOfMemoryError: Java heap space `\n\n解决方案，调整jvm参数，扩大老年代比率，或者直接扩大堆空间\n\n## Permanet Generation空间满\n\n连续多次触发full gc， Permanet Generation空间占比高\n\n解决方案：扩大Perm 大小\n\n## CMS GC时出现promotion failed和concurrent mode failure\n查询gc日志\npromotion failed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。\n\n解决方案：增大survivor space、old gen 空间\n\n## Serial Old GC／PS MarkSweep GC／Parallel Old GC的触发则是在要执行Young GC时候预测其promote的object的总size超过老生代剩余size\n解决方案：增大old gen 空间\n"}]